formato aritméticas: 
op	rs	rt	rd	shamt	funct
000001	00001	00010  	00011  	00000	000000  ADD R3, R1, R2

formato lw, sw, beq:
op	rs	rt		inm
000010 	00000	00001 	0000000000000000 		LW  R1, 0(R0)  dir 0

codigo inicial en la ram de instrucciones: 
El valor inicial de los registros es 0 (partimos de un reset) 
Es un bucle infinito
El código está pensado para funcionar en un procesador con saltos 1-retardados que no detecta los riesgos de datos 

separado por campos:

000010 	00000	00001 	0000000000000000		@0x0LW  R1, 0(R0)
000010 	00000	00010 	0000000000000100 		@0x4	LW  R2, 4(R0)
000000	00000	00000	0000000000000000		@0x8	nop
000000	00000	00000	0000000000000000	inm:@0xC	nop
000001	00001	00010  	0001100000000000		@0x10	ADD R3, R1, R2	
000000	00000	00000	0000000000000000		@0x14	nop
000000	00000	00000	0000000000000000		@0x18	nop
000011 	00000	00011 	0000000000001000 		@0x1C	SW  R3, 8(R0)
000100	00000	00000	1111111111111010		@0x20	beq r0, r0, inm
000000	00000	00000	0000000000000000		@0x24	nop
; queremos saltar a la posición C, 
; el procesador calcula la dirección haciendo PC+4+ 4*ext(inm)
; si estamos en la 26 y queremos ir a la 12 hay que restar 24. 4*ext(inm)= -24. inm = -6 = 0xFFFA
; El procesador en beq calculara 0xfffa*4+001C= 0xC	


EN hexadecimal:

00001000000000010000000000000000 	08010000	LW  R1, 0(R0)
00001000000000100000000000000100 	08020004	LW  R2, 4(R0)
00000000000000000000000000000000	00000000	nop
00000000000000000000000000000000	00000000	nop
00000100001000100001100000000000  	04221800	ADD R3, R1, R2
00000000000000000000000000000000	00000000	nop
00000000000000000000000000000000	00000000	nop
00001100000000110000000000000100 	0C030008	SW  R3, 8(R0)
00010000000000001111111111111010	1000FFFa	beq r0, r0, inm; 
00000000000000000000000000000000	00000000	nop
